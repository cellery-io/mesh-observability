/*
 * Copyright (c) 2019, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
 *
 * WSO2 Inc. licenses this file to you under the Apache License,
 * Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

@App:name("tracing-app")
@App:description("Cellery Tracing Siddhi App for processing and storing trace spans")

@source(type="tracing-receiver", host="0.0.0.0", port="9411", api.context="/api/v1/spans",
        @map(type="keyvalue", fail.on.missing.attribute="false"))
define stream ZipkinStreamIn(traceId string, id string, parentId string, operationName string, serviceName string,
                             spanKind string, timestamp long, duration long, tags string);

@source(type="inMemory", topic="istio-mixer-report", @map(type="passThrough"))
define stream TelemetryStreamIn(requestId string, traceId string, spanId string, sourceNamespace string,
                                sourceInstance string, sourceInstanceKind string, sourceComponent string,
                                sourcePod string, destinationNamespace string, destinationInstance string,
                                destinationInstanceKind string, destinationComponent string, destinationPod string,
                                contextReporterKind string, requestPath string, requestMethod string,
                                requestSizeBytes long, responseCode long, responseDurationNanoSec long,
                                responseSizeBytes long);

@Store(type="rdbms", datasource="CELLERY_OBSERVABILITY_DB", field.length="tags:8000")
@PrimaryKey("traceId", "spanId", "spanKind")
@purge(enable="false")
define table DistributedTracingTable(traceId string, spanId string, parentId string, namespace string, instance string,
                                     instanceKind string, serviceName string, pod string, operationName string,
                                     spanKind string, startTime long, duration long, tags string);

define function extractFromServiceName[javascript] return string {
    var serviceName = data[0];
    var index = data[1];    // 1: instance, 2: service

    var cellGatewayMatches = /^src:\d+\.\d+\.\d+\.(.+)_\d+_\d+_\d+_.+$/.exec(serviceName);
    var mircoserviceMatches = /^(.+)--(.+)--(.+)\.(.+)$/.exec(serviceName);

    var extractedData = "";
    if (cellGatewayMatches) {
        var cell = cellGatewayMatches[1];
        if (index == 1) {
            extractedData = cell;
        } else if (index == 2) {
            extractedData = "gateway";
        } else if (index == 3) {
            extractedData = "cellery-system"
        }
    } else if (mircoserviceMatches) {
        extractedData = mircoserviceMatches[index];
        if (index == 3) {
            if (extractedData == "cell") {
                extractedData = "Cell";
            } else if (extractedData == "composite") {
                extractedData = "Composite";
            } else {
                extractedData = "";
            }
        }
    }

    // Handling service names that does not match any of the regexes
    if (!extractedData && index == 2) {
        extractedData = serviceName;
    }
    return extractedData.replace(/_/g, "-");
};

--
-- Storing Zipkin data received for Tracing
--

from ZipkinStreamIn
select
    traceId,
    id as spanId,
    parentId,
    extractFromServiceName(serviceName, 4) as namespace,
    extractFromServiceName(serviceName, 1) as instance,
    extractFromServiceName(serviceName, 3) as instanceKind,
    extractFromServiceName(serviceName, 2) as serviceName,
    "" as pod,
    operationName,
    spanKind,
    timestamp as startTime,
    duration,
    tags
insert into ProcessedZipkinStream;

from ProcessedZipkinStream#observe:traceGroupWindow(60 sec,traceId)#observe:modelGenerator(instance, serviceName, operationName, spanId, parentId, spanKind, traceId, startTime)
update or insert into DistributedTracingTable
    set DistributedTracingTable.parentId = parentId,
        DistributedTracingTable.operationName = operationName,
        DistributedTracingTable.startTime = startTime,
        DistributedTracingTable.duration = duration,
        DistributedTracingTable.tags = tags
    on DistributedTracingTable.traceId == traceId and DistributedTracingTable.spanId == spanId
        and DistributedTracingTable.spanKind == spanKind;

--
-- Filling additional data from Telemetry
--

-- Extracting information for local service
from TelemetryStreamIn
select
    traceId,
    spanId,
    ifThenElse(contextReporterKind == "inbound", "SERVER", "CLIENT") as spanKind,
    ifThenElse(contextReporterKind == "inbound", destinationNamespace, sourceNamespace) as namespace,
    ifThenElse(contextReporterKind == "inbound", destinationInstance, sourceInstance) as instance,
    ifThenElse(contextReporterKind == "inbound", destinationInstanceKind, sourceInstanceKind) as instanceKind,
    ifThenElse(contextReporterKind == "inbound", destinationComponent, sourceComponent) as serviceName,
    ifThenElse(contextReporterKind == "inbound", destinationPod, sourcePod) as pod
insert into ProcessedTelemetryDataStream;

-- Extracting information for remote service
from TelemetryStreamIn
select
    traceId,
    spanId,
    ifThenElse(contextReporterKind == "inbound", "CLIENT", "SERVER") as spanKind,
    ifThenElse(contextReporterKind == "inbound", sourceNamespace, destinationNamespace) as namespace,
    ifThenElse(contextReporterKind == "inbound", sourceInstance, destinationInstance) as instance,
    ifThenElse(contextReporterKind == "inbound", sourceInstanceKind, destinationInstanceKind) as instanceKind,
    ifThenElse(contextReporterKind == "inbound", sourceComponent, destinationComponent) as serviceName,
    ifThenElse(contextReporterKind == "inbound", sourcePod, destinationPod) as pod
insert into ProcessedTelemetryDataStream;

from ProcessedTelemetryDataStream[(not serviceName is null) and (serviceName != "")]
select
    traceId,
    spanId,
    "" as parentId,
    namespace,
    ifThenElse(instance is null, extractFromServiceName(serviceName, 1), instance) as instance,
    instanceKind,
    extractFromServiceName(serviceName, 2) as serviceName,
    pod,
    "" as operationName,
    spanKind,
    0L as startTime,
    0L as duration,
    "{}" as tags
insert into ExtractedTelemetryDataStream;

from every(e1=ExtractedTelemetryDataStream) ->
    not ExtractedTelemetryDataStream[e1.traceId == e2.traceId and e1.spanId == e2.spanId and e1.spanKind == e2.spanKind] for 1 minute
    or e2=ExtractedTelemetryDataStream[e1.traceId == e2.traceId and e1.spanId == e2.spanId and e1.spanKind == e2.spanKind] within 1 minute
select
    e1.traceId,
    e1.spanId,
    e1.parentId,
    ifThenElse(e1.namespace is null, e2.namespace, e1.namespace) as namespace,
    ifThenElse(e1.instance is null, e2.instance, e1.instance) as instance,
    ifThenElse(e1.instanceKind is null, e2.instanceKind, e1.instanceKind) as instanceKind,
    ifThenElse(e1.serviceName is null, e2.serviceName, e1.serviceName) as serviceName,
    ifThenElse(e1.pod is null, e2.pod, e1.pod) as pod,
    e1.operationName,
    e1.spanKind,
    e1.startTime,
    e1.duration,
    e1.tags
insert into UniqueTelemetryDataStream;

from UniqueTelemetryDataStream[(not traceId is null) and (not spanId is null)]
update or insert into DistributedTracingTable
    set DistributedTracingTable.namespace = namespace,
        DistributedTracingTable.instance = instance,
        DistributedTracingTable.serviceName = serviceName,
        DistributedTracingTable.instanceKind = instanceKind,
        DistributedTracingTable.pod = pod
    on DistributedTracingTable.traceId == traceId and DistributedTracingTable.spanId == spanId
        and DistributedTracingTable.spanKind == spanKind;
